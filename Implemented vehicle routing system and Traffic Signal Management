#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

using namespace std;

class Node
{
public:
    char vertx;
    int weight;
    string status;
    Node *next;

    Node(char ver, int w, string st = "Clear")
    {
        vertx = ver;
        weight = w;
        next = nullptr;
    }
};

class Graph
{
public:
    Node **array;
    int num_nodes;

    Graph(int size)
    {
        num_nodes = size;
        array = new Node *[num_nodes];
        for (int i = 0; i < num_nodes; ++i)
        {
            array[i] = nullptr;
        }
    }

    void addEdge(char point_1, char point_2, int weight, string st = "Clear")
    {

        int start = point_1 - 'A';
        int end = point_2 - 'A';

        Node *n_node_start = new Node(point_2, weight, st);
        n_node_start->next = array[start];
        array[start] = n_node_start;

        Node *n_node_end = new Node(point_1, weight, st);
        n_node_end->next = array[end];
        array[end] = n_node_end;
    }

    void dijkstra(char a, char b, int roadCounts[26][26])
    {
        int A_point = a - 'A';
        int B_point = b - 'A';
        int *distance = new int[num_nodes];
        bool *visited = new bool[num_nodes]; // check which noode has been visited
        char *prev = new char[num_nodes];
        int *PQ = new int[num_nodes]; // priority queue
        int queue_size = 0;

        for (int i = 0; i < num_nodes; i++)
        {
            distance[i] = 10000000; // Represent infinity
            visited[i] = false;
            prev[i] = '\0';
            PQ[i] = -1;
        }
        distance[A_point] = 0;
        PQ[queue_size++] = A_point;

        while (queue_size > 0)
        {
            // Find the vertex with the minimum distanceance
            int minIndex = -1;
            int minValue = 10000000; // represnet infinity
            for (int i = 0; i < queue_size; i++)
            {
                int v = PQ[i];
                if (!visited[v] && distance[v] < minValue)
                {
                    minValue = distance[v];
                    minIndex = v;
                }
            }

            if (minIndex == -1)
                break; // No more vertices to process

            // Remove minIndex from the priority queue
            for (int i = 0; i < queue_size; i++)
            {
                if (PQ[i] == minIndex)
                {
                    PQ[i] = PQ[--queue_size];
                    break;
                }
            }

            visited[minIndex] = true;

            Node *temp = array[minIndex];
            while (temp)
            {
                int adjIndex = temp->vertx - 'A';

                // skip road if blocked
                if (temp->status == "Blocked")
                {
                    temp = temp->next;
                    continue;
                }

                if (!visited[adjIndex] && distance[minIndex] + temp->weight < distance[adjIndex])
                {
                    distance[adjIndex] = distance[minIndex] + temp->weight;
                    prev[adjIndex] = minIndex + 'A';

                    bool inQueue = false;
                    for (int i = 0; i < queue_size; i++)
                    {
                        if (PQ[i] == adjIndex)
                        {
                            inQueue = true;
                            break;
                        }
                    }
                    if (!inQueue)
                    {
                        PQ[queue_size++] = adjIndex;
                    }
                }
                temp = temp->next;
            }
        }

        char path[num_nodes];
        int pathLength = 0;

        // Trace the path back from the destination
        int i = B_point;
        while (i != '\0' - 'A')
        {
            path[pathLength++] = i + 'A';
            i = prev[i] - 'A';
        }

        for (int i = 0; i < pathLength / 2; i++)
        {
            char temp = path[i];
            path[i] = path[pathLength - 1 - i];
            path[pathLength - 1 - i] = temp;
        }

        for (int i = 0; i < pathLength - 1; i++)
        {
            char A_point = path[i];
            char B_point = path[i + 1];
            roadCounts[A_point - 'A'][B_point - 'A'] = roadCounts[A_point - 'A'][B_point - 'A'] + 1;
            roadCounts[B_point - 'A'][A_point - 'A'] = roadCounts[B_point - 'A'][A_point - 'A'] + 1;
        }

        // printing path
        cout << "Shortest path from " << a << " to " << b << ": ";
        for (int i = 0; i < pathLength; i++)
        {
            cout << path[i] << " ";
        }
        cout << "with total distanceance: " << distance[B_point] << endl;

        delete[] distance;
        delete[] visited;
        delete[] prev;
        delete[] PQ;
    }

    void
    display_graph()
    {
        for (int i = 0; i < num_nodes; ++i)
        {
            cout << char('A' + i) << " -> ";
            Node *temp = array[i];
            while (temp)
            {
                cout << "(" << temp->vertx << ", " << temp->weight << ") ";
                temp = temp->next;
            }
            cout << endl;
        }
    }

    string check_road_status(char start, char end)
    {
        int a = start - 'A';
        int b = end - 'A';

        Node *temp = array[a];
        while (temp)
        {
            if (temp->vertx == end)
            {
                return temp->status;
            }
            temp = temp->next;
        }

        return "No road between "; // No road exists between the two nodes
    }

    void displayblockroads()
    {
        for (int i = 0; i < num_nodes; i++)
        {
            Node *temp = array[i];
            while (temp)
            {
                if (temp->status == "Blocked")
                {

                    cout << char('A' + i) << " to " << temp->vertx << " is blocked" << endl;
                    break;
                }
                temp = temp->next;
            }
        }
    }

    void Blocking_road(char start, char end)
    {
        if (check_road_status(start, end) == "Blocked")
        {
            cout << "Road is already blocked" << endl;
            return;
        }
        else if (check_road_status(end, start) == "No road between")
        {
            cout << "Road is already blocked" << endl;
            return;
        }
        Node *temp = array[start - 'A'];
        while (temp)
        {
            if (temp->vertx == end)
            {
                temp->status = "Blocked";
                break;
            }
            temp = temp->next;
        }

        temp = array[end - 'A'];
        while (temp)
        {
            if (temp->vertx == start)
            {
                temp->status = "Blocked";
                break;
            }
            temp = temp->next;
        }
    }

    // void detectCongestionAndInaccessiblePaths(int congestionThreshold)
    // {
    //     bool visited[num_nodes] = {false};
    //     cout << "Detecting congestion zones and inaccessible paths:\n";

    //     for (int i = 0; i < num_nodes; ++i)
    //     {
    //         if (!visited[i])
    //         {
    //             detectCongestionDFS(i, visited, congestionThreshold);
    //         }
    //     }
    // }

    ~Graph()
    {
        for (int i = 0; i < num_nodes; ++i)
        {
            Node *temp = array[i];
            while (temp)
            {
                Node *toDelete = temp;
                temp = temp->next;
                delete toDelete;
            }
        }
        delete[] array;
    }

private:
    // void detectCongestionDFS(int node, bool visited[], int congestionThreshold)
    // {
    //     visited[node] = true;
    //     Node *temp = array[node];

    //     while (temp)
    //     {
    //         int adjIndex = temp->vertx - 'A';

    //         // Check for congestion
    //         if (temp->weight > congestionThreshold)
    //         {
    //             cout << "Congestion detected on road from " << char('A' + node) << " to " << temp->vertx << endl;
    //         }

    //         // Check for inaccessible paths
    //         if (temp->status == "Blocked")
    //         {
    //             cout << "Inaccessible path from " << char('A' + node) << " to " << temp->vertx << " (Blocked)" << endl;
    //         }
    //         else if (!visited[adjIndex])
    //         {
    //             detectCongestionDFS(adjIndex, visited, congestionThreshold);
    //         }

    //         temp = temp->next;
    //     }
    // }
};

class Vehicle
{
public:
    string ID;
    char Start;
    char End;

    Vehicle()
    {
        ID = "";
        Start = '\0';
        End = '\0';
    }

    void add_vehicle(string id, char start, char end)
    {
        ID = id;
        Start = start;
        End = end;
    }
    void display()
    {
        cout << "vehicle  " << ID << ", point  " << Start << " to " << End << endl;
    }
};

class Trafic_signal
{
public:
    char node;
    int green_duration;

    Trafic_signal()
    {
        node = '\0';
        green_duration = 0;
    }

    void add_signal(char n, int duration)
    {
        node = n;
        green_duration = duration;
    }

    void display()
    {
        cout << "Traffic Signal Node: " << node << ", Green Duration: " << green_duration << "A_point" << endl;
    }
};
class EmergencyVehicle
{
public:
    string ID;
    char Start;
    char End;
    string PriorityLevel;

    EmergencyVehicle()
    {
        ID = "";
        Start = '\0';
        End = '\0';
        PriorityLevel = "";
    }

    void add_emergency_vehicle(string id, char start, char end, string priority)
    {
        ID = id;
        Start = start;
        End = end;
        PriorityLevel = priority;
    }

    // void display()
    // {
    //     cout << "Emergency Vehicle ID: " << ID << ", Start: " << Start << ", End: " << End << ", Priority Level: " << PriorityLevel << endl;
    // }
};

// read graph
void read_nodes(string filename, Graph &g)
{
    ifstream file(filename);
    string line;

    getline(file, line); // Skip header
    while (getline(file, line))
    {
        stringstream ss(line);
        string a, b, w; // a,b,w->start end and weight

        getline(ss, a, ',');
        getline(ss, b, ',');
        getline(ss, w);

        char start = a[0];
        char end = b[0];
        int weight = stoi(w);

        g.addEdge(start, end, weight);
    }
    file.close();
}

// read vehicles
int read_vehicles(string name, Vehicle vehicles[], int max)
{
    ifstream file(name);
    string line;
    int count = 0;

    getline(file, line); // Skip first line

    while (getline(file, line) && count < max)
    {
        stringstream ss(line);
        string id, start, end;

        getline(ss, id, ',');
        getline(ss, start, ',');
        getline(ss, end);

        vehicles[count].add_vehicle(id, start[0], end[0]);
        count++;
    }
    file.close();
    return count;
}

int read_trafic_signals(string name, Trafic_signal signals[], int max)
{
    ifstream file(name);
    string line;
    int count = 0;

    getline(file, line); // Skip header
    while (getline(file, line) && count < max)
    {
        stringstream ss(line);
        string node, time;

        getline(ss, node, ',');
        getline(ss, time);

        char n = node[0];
        int t = stoi(time); // time is string so we need to convert it to int

        signals[count].add_signal(n, t);
        count++;
    }
    file.close();
    return count;
}

int read_emergency_vehicles(string name, EmergencyVehicle emergencyVehicles[], int max)
{
    ifstream file(name);
    string line;
    int count = 0;

    getline(file, line); // Skip header

    while (getline(file, line) && count < max)
    {
        stringstream ss(line);
        string id, start, end, priority;

        getline(ss, id, ',');
        getline(ss, start, ',');
        getline(ss, end, ',');
        getline(ss, priority);

        emergencyVehicles[count].add_emergency_vehicle(id, start[0], end[0], priority);
        count++;
    }
    file.close();
    return count;
}

void read_road_closures(string filename, Graph &g)
{
    ifstream file(filename);
    string line;

    getline(file, line); // Skip header
    while (getline(file, line))
    {
        stringstream ss(line);
        string a, b, status;

        getline(ss, a, ','); // Start node
        getline(ss, b, ','); // End node
        getline(ss, status); // Road status

        char start = a[0];
        char end = b[0];

        // Update the adjacency list to store the road status for the first direction
        Node *temp = g.array[start - 'A'];
        bool statusUpdated = false;
        while (temp)
        {
            if (temp->vertx == end)
            {
                temp->status = status; // Update the road status
                statusUpdated = true;
                break;
            }
            temp = temp->next;
        }

        // Only update the reverse direction if the road was not blocked already
        if (!statusUpdated)
        {
            temp = g.array[end - 'A'];
            while (temp)
            {
                if (temp->vertx == start)
                {
                    temp->status = status; // Update the road status

                    break;
                }
                temp = temp->next;
            }
        }
    }
    file.close();
}
// Simulate vehicles and count vertex visits
void simulate_vehicles(Graph &g, Vehicle vehicles[], int vehicleCount, int num_vertices)
{
    int vertexVisits[26] = {0}; // Hash table using array

    cout << "\nSimulating vehicle movements:\n";
    for (int i = 0; i < vehicleCount; ++i)
    {
        cout << "\nVehicle " << vehicles[i].ID << ":\n";
        int roadCounts[26][26] = {0};
        g.dijkstra(vehicles[i].Start, vehicles[i].End, roadCounts);

        // Count vertex visits
        for (int j = 0; j < 26; ++j)
        {
            for (int k = 0; k < 26; ++k)
            {
                if (roadCounts[j][k] > 0)
                {
                    vertexVisits[j] += roadCounts[j][k];
                }
            }
        }
    }

    cout << "\nVertex visit frequencies:\n";
    for (int i = 0; i < num_vertices; ++i)
    {
        if (vertexVisits[i] > 0)
        {
            cout << char('A' + i) << ": " << vertexVisits[i] << " times\n";
        }
    }
}
int main()
{

    int number_verteces = 26;
    Graph g(number_verteces);
    read_nodes("road.csv", g);
    int roadCounts[26][26] = {0};
    Vehicle vehicles[100];

    int choice;
    bool check = true;

    while (check)
    {
        cout << "\nSmart Traffic Management System Simulator\n";
        cout << "------------------------------------------\n";
        cout << "1. Display City Traffic Network" << endl;
        cout << "2. Display Traffic Signal" << endl;
        cout << "3. Display Congestion Status" << endl;
        cout << "4. Display Blocked Road" << endl;
        cout << "5. Handle Emergency Vehicle Routing" << endl;
        cout << "6. Block Road due to Accident" << endl;
        cout << "7. Simulate Vehicle Routing " << endl;
        cout << "8. Exit Simulation" << endl;
        cout << "Enter your Choice: ";

        cin >> choice;

        if (choice == 1)
        {
            cout << "Displaying City Traffic Network...\n";
            g.display_graph();
            cout << endl;
        }
        else if (choice == 2)
        {
            cout << "Displaying Traffic Signal...\n";
        }
        else if (choice == 3)
        {
            cout << "Displaying Congestion Status...\n";
            int vehicleCount = read_vehicles("vehicles.csv", vehicles, 100);
            cout << "\nCalculating routes for all vehicles:" << endl;
            for (int i = 0; i < vehicleCount; ++i)
            {
                g.dijkstra(vehicles[i].Start, vehicles[i].End, roadCounts);
            }
            for (int i = 0; i < number_verteces; i++)
            {
                for (int j = i + 1; j < number_verteces; j++)
                {
                    if (roadCounts[i][j] > 0)
                    {
                        cout << char('A' + i) << " -> " << char('A' + j)
                             << ": " << roadCounts[i][j] << " vehicles" << endl;
                    }
                }
            }
        }
        else if (choice == 4)
        {
            cout << "Displaying Blocked Road...\n";
            read_road_closures("road_closures.csv", g);
            g.displayblockroads();
        }
        else if (choice == 5)
        {
            cout << "Routing Emergency Vehicles...\n";
            cout << "Enter the route for emergency vehicle: ";
            char start, end;
            cout << "start: ";
            cin >> start;
            cout << "end: ";
            cin >> end;
            g.dijkstra(start, end, roadCounts);
        }
        else if (choice == 6)
        {
            cout << "Blocking a Road...\n";
            cout << "Enter the road to block: ";
            char start, end;
            cout << "start: ";
            cin >> start;
            cout << "end: ";
            cin >> end;
            g.Blocking_road(start, end);
        }
        else if (choice == 7)
        {
            cout << "Simulating Vehicle Routing for All Paths...\n";
        }
        else if (choice == 8)
        {
            cout << "Exiting Simulation...\n";
            check = false;
        }
        else
        {
            cout << "Invalid choice. Please try again.\n";
        }
    }
    // char a = 'A'; // Change this to the desired starting vertex
    // char b = 'F';   // Change this to the desired end vertex
    // g.dijkstra(a, b);
    // Step 3: Read Vehicles

    // // Display vehicles
    // for (int i = 0; i < vehicleCount; ++i)
    // {
    //     vehicles[i].display();
    // }

    // Step 4 : Read Traffic Signals
    // Trafic_signal signals[100];
    // int signalCount = read_trafic_signals("traffic_signals.csv", signals, 100);

    // // Display traffic signals
    // for (int i = 0; i < signalCount; ++i)
    // {
    //     signals[i].display();
    // }

    // EmergencyVehicle emergencyVehicles[100];
    // int c;
    // c = read_emergency_vehicles("emergency_vehicles.csv", emergencyVehicles, 100);

    // for (int i = 0; i < c; ++i)
    // {
    //     emergencyVehicles[i].display();
    // }
    // cout << "\nReading road closures from 'road_closures.csv'..." << endl;

    // // // // cout << endl
    // // // //      << endl;
    // // // g.displayblockroads();
    // g.Blocking_road('B', 'F');

    // // g.dijkstra('A', 'F', roadCounts);
    // // simulate_vehicles(g, vehicles, vehicleCount, number_verteces);

    // simulate_vehicles(g, vehicles, vehicleCount, number_verteces);
    return 0;
}
