//Group Members
//Abdullah ilyas (23i-2603) ,Mahd Kazmi (23i-2587) , Muhammad Azmat  (23i-2651)
//Section:DS-C



#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

using namespace std;

class Node
{
public:
    char vertx;
    int weight;
    string status;
    Node *next;

    Node(char ver, int w, string st = "Clear")
    {
        vertx = ver;
        weight = w;
        next = nullptr;
    }
};
struct PathNode
{
    int path[26];
    int length;
};
class Graph
{
public:
    Node **array;
    int size;

    Graph(int s)
    {
        size = s;
        array = new Node *[size];
        for (int i = 0; i < size; ++i)
        {
            array[i] = nullptr;
        }
    }

    void addEdge(char point_1, char point_2, int weight, string st = "Clear")
    {

        int a = point_1 - 'A';
        int b = point_2 - 'A';
        Node *n_node_start = new Node(point_2, weight, st);
        // insert at tail
        if (array[a] == nullptr) // if list  is empty  insert at head
        {
            array[a] = n_node_start;
        }
        else
        {
            Node *temp = array[a];
            while (temp->next != nullptr) // traverse to last node and add node
            {
                temp = temp->next;
            }
            temp->next = n_node_start;
        }

        Node *n_node_end = new Node(point_1, weight, st);

        // insert at tail
        if (array[b] == nullptr)
        {
            array[b] = n_node_end;
        }
        else
        {
            Node *temp = array[b];
            while (temp->next != nullptr)
            {
                temp = temp->next;
            }
            temp->next = n_node_end;
        }
    }
    void removeEdge(char point_1, char point_2)
    {
        int a = point_1 - 'A';
        int b = point_2 - 'A';

        // Remove edge from point_1 to point_2
        Node *current = array[a];
        Node *prev = nullptr;

        while (current != nullptr && current->vertx != point_2)
        {
            prev = current;
            current = current->next;
        }

        if (current != nullptr)
        {
            if (prev == nullptr)
            {
                array[a] = current->next;
            }
            else
            {
                prev->next = current->next;
            }
            delete current;
        }

        // Remove edge from point_2 to point_1
        current = array[b];
        prev = nullptr;

        while (current != nullptr && current->vertx != point_1)
        {
            prev = current;
            current = current->next;
        }

        if (current != nullptr)
        {
            if (prev == nullptr)
            {
                array[b] = current->next;
            }
            else
            {
                prev->next = current->next;
            }
            delete current;
        }
    }

    void dijkstra_algorithm(char a, char b, int road_count[26][26])
    {
        // index to iterate list
        int A_point = a - 'A';
        int B_point = b - 'A';
        int *distance = new int[size];
        bool *visited = new bool[size];  // check which noode has been visited
        char *prevoius = new char[size]; // array to store prevoius node
        int *PQ = new int[size];         // priority queue
        int queue_size = 0;

        for (int i = 0; i < size; i++)
        {
            distance[i] = 10000000; // in priority queue each node distance first marked as infinity so we take large number
            visited[i] = false;
            prevoius[i] = '\0';
            PQ[i] = -1;
        }
        distance[A_point] = 0;
        PQ[queue_size++] = A_point;

        while (queue_size > 0)
        {
            int min_index = -1;
            int value = 10000000;
            for (int i = 0; i < queue_size; i++)
            {
                int k = PQ[i];
                if (!visited[k] && distance[k] < value)
                {
                    value = distance[k];
                    min_index = k;
                }
            }

            if (min_index == -1)
                break;

            for (int i = 0; i < queue_size; i++)
            {
                if (PQ[i] == min_index)
                {
                    queue_size = queue_size - 1;
                    PQ[i] = PQ[queue_size];
                    break;
                }
            }

            visited[min_index] = true;

            Node *temp = array[min_index];
            while (temp)
            {
                int index = temp->vertx - 'A';

                if (temp->status == "Blocked") // skip if road is blocked
                {
                    temp = temp->next;
                    continue;
                }

                if (!visited[index] && distance[min_index] + temp->weight < distance[index])
                {
                    distance[index] = distance[min_index] + temp->weight;
                    prevoius[index] = min_index + 'A';

                    bool inQueue = false;
                    for (int i = 0; i < queue_size; i++)
                    {
                        if (PQ[i] == index)
                        {
                            inQueue = true;
                            break;
                        }
                    }
                    if (!inQueue)
                    {
                        PQ[queue_size++] = index;
                    }
                }
                temp = temp->next;
            }
        }

        char path[size];
        int l = 0; // lenght of path

        int i = B_point;
        while (i != '\0' - 'A')
        {
            path[l] = i + 'A';
            l++;
            i = prevoius[i] - 'A';
        }
        // reverse the path as it store in reverse oder so we revrese it and then print
        for (int i = 0; i < l / 2; i++)
        {
            char temp = path[i];
            path[i] = path[l - 1 - i];
            path[l - 1 - i] = temp;
        }
        // count the number of times each road is used and vehciles are counted on basis of path
        for (int i = 0; i < l - 1; i++)
        {
            char A_point = path[i];
            char B_point = path[i + 1];
            road_count[A_point - 'A'][B_point - 'A'] = road_count[A_point - 'A'][B_point - 'A'] + 1;
            road_count[B_point - 'A'][A_point - 'A'] = road_count[B_point - 'A'][A_point - 'A'] + 1;
        }

        // printing path
        cout << "Shortest path from " << a << " to " << b << ": ";
        for (int i = 0; i < l; i++)
        {
            cout << path[i] << " ";
        }
        cout << "with total distance: " << distance[B_point] << endl;

        // delete[] distance;
        // delete[] visited;
        // delete[] prevoius;
        // delete[] PQ;
    }

    void
    display_graph()
    {
        for (int i = 0; i < size; i++)
        {
            cout << char('A' + i) << " -> ";
            Node *temp = array[i];
            while (temp)
            {
                cout << "(" << temp->vertx << ", " << temp->weight << ") ";
                temp = temp->next;
            }
            cout << endl;
        }
    }

    string check_road_status(char start, char end)
    {
        int a = start - 'A';
        int b = end - 'A';

        Node *temp = array[a];
        while (temp)
        {
            if (temp->vertx == end)
            {
                return temp->status;
            }
            temp = temp->next;
        }

        return "No road between "; // No road exists between the two nodes
    }

    void displayblockroads()
    {
        for (int i = 0; i < size; i++)
        {
            Node *temp = array[i];
            while (temp)
            {
                if (temp->status == "Blocked")
                {

                    cout << char('A' + i) << " to " << temp->vertx << " is blocked" << endl;
                    break;
                }
                temp = temp->next;
            }
        }
    }
    void print_path_bfs(char start, char end)
    {
        bool visited[26] = {false};
        char path[26];
        int length = 0;
        path_printing(start - 'A', end - 'A', visited, path, length);
    }

    void path_printing(int current, int dest, bool visited[], char path[], int path_length)
    {
        visited[current] = true;
        path[path_length] = current + 'A';

        if (current == dest)
        {
            string whole_path(path, path_length + 1);
            int weight = findPathWeight(whole_path);
            cout << whole_path << " Total Weight: " << weight << endl;
        }
        else
        {
            Node *temp = array[current];
            while (temp)
            {
                int next_point = temp->vertx - 'A';
                if (!visited[next_point] && temp->status != "Blocked")
                {
                    path_printing(next_point, dest, visited, path, path_length + 1);
                }
                temp = temp->next;
            }
        }

        visited[current] = false;
    }
    void Blocking_road(char start, char end)
    {
        if (check_road_status(start, end) == "Blocked")
        {
            cout << "Road is already blocked" << endl;
            return;
        }
        else if (check_road_status(end, start) == "No road between")
        {
            cout << "no road between " << start << " and " << end << endl;
            return;
        }
        else
        {
            Node *temp = array[start - 'A'];
            while (temp)
            {
                if (temp->vertx == end)
                {
                    temp->status = "Blocked";
                    break;
                }
                temp = temp->next;
            }
            temp = array[end - 'A'];
            while (temp)
            {
                if (temp->vertx == start)
                {
                    temp->status = "Blocked";
                    break;
                }
                temp = temp->next;
            }
        }
    }
    int findPathWeight(string whole_path)
    {
        int l = whole_path.length();
        int total_weight = 0;
        for (int i = 0; i < l - 1; i++)
        {
            char A_point = whole_path[i];
            char B_point = whole_path[i + 1];
            // here we are finding the weight of the path first calculate 0 index and 1 index weight and incrementally adding the weight
            Node *temp = array[A_point - 'A'];
            while (temp && temp->vertx != B_point)
            {
                temp = temp->next;
            }
            if (temp)
            {
                total_weight = total_weight + temp->weight;
            }
        }
        return total_weight;
    }

    void print_path__bfs(char start, char end)
    {
        struct PathNode
        {
            int path[26];
            int length;
        };

        PathNode stack[10000];
        int top_index = -1;
        PathNode path_array;
        path_array.path[0] = start - 'A';
        path_array.length = 1; // initailze length 1 then increase
        stack[top_index] = path_array;
        top_index = top_index + 1;

        while (top_index >= 0)
        {

            PathNode a = stack[top_index];
            top_index--;
            int last = a.path[a.length - 1];
            if (last == end - 'A')
            {
                string string_path;
                for (int i = 0; i < a.length; ++i)
                    string_path += (a.path[i] + 'A');
                int weight = findPathWeight(string_path);
                cout << string_path << " Total Weight: " << weight << endl;
            }
            else
            {
                Node *temp = array[last];
                while (temp)
                {
                    int adjVertex = temp->vertx - 'A';
                    bool visited = false;
                    for (int i = 0; i < a.length; ++i)
                    {
                        if (a.path[i] == adjVertex)
                        {
                            visited = true;
                            break;
                        }
                    }

                    if (!visited && temp->status != "Blocked")
                    {
                        PathNode new_Path;

                        for (int i = 0; i < a.length; ++i)
                        {
                            new_Path.path[i] = a.path[i];
                        }
                        new_Path.path[a.length] = adjVertex;
                        new_Path.length = a.length + 1;

                        // Push the new path onto the stack
                        stack[++top_index] = new_Path;
                    }
                    temp = temp->next;
                }
            }
        }
    }

    ~Graph()
    {
        for (int i = 0; i < size; ++i)
        {
            Node *temp = array[i];
            while (temp)
            {
                Node *a = temp;
                temp = temp->next;
                delete a;
            }
        }
        delete[] array;
    }
};

class Vehicle
{
public:
    string ID;
    char Start;
    char End;

    Vehicle()
    {
        ID = "";
        Start = '\0';
        End = '\0';
    }

    void add_vehicle(string id, char start, char end)
    {
        ID = id;
        Start = start;
        End = end;
    }
    void display()
    {
        cout << "vehicle  " << ID << ", point  " << Start << " to " << End << endl;
    }
};

class Trafic_signal
{
public:
    char node;
    int green_duration;

    Trafic_signal()
    {
        node = '\0';
        green_duration = 0;
    }

    void add_signal(char n, int duration)
    {
        node = n;
        green_duration = duration;
    }

    void display()
    {
        cout << "Interaction " << node << ", Green Time: " << green_duration << "s" << endl;
    }
};
class Emergency_Vehicle
{
public:
    string ID;
    char Start;
    char End;
    string Priority_Level;

    Emergency_Vehicle()
    {
        ID = "";
        Start = '\0';
        End = '\0';
        Priority_Level = "";
    }

    void add_emergency_vehicle(string id, char start, char end, string priority)
    {
        ID = id;
        Start = start;
        End = end;
        Priority_Level = priority;
    }
    void display()
    {
        cout << "Emergency Vehicle ID: " << ID << ", Start: " << Start << ", End: " << End << ", Priority Level: " << Priority_Level << endl;
    }
};

// read graph
void read_nodes(string filename, Graph &g)
{
    ifstream file(filename);
    string line;

    getline(file, line); // Skip header
    while (getline(file, line))
    {
        stringstream ss(line);
        string a, b, w; // a,b,w->start end and weight

        getline(ss, a, ',');
        getline(ss, b, ',');
        getline(ss, w);

        char start = a[0];
        char end = b[0];
        int weight = stoi(w);

        g.addEdge(start, end, weight);
    }
    file.close();
}

// read vehicles
int read_vehicles(string name, Vehicle vehicles[], int max)
{
    ifstream file(name);
    string line;
    int count = 0;

    getline(file, line);

    while (getline(file, line) && count < max)
    {
        stringstream ss(line);
        string id, start, end;

        getline(ss, id, ',');
        getline(ss, start, ',');
        getline(ss, end);

        vehicles[count].add_vehicle(id, start[0], end[0]);
        count++;
    }
    file.close();
    return count;
}

int read_trafic_signals(string name, Trafic_signal signals[], int max)
{
    ifstream file(name);
    string line;
    int count = 0;

    getline(file, line);
    while (getline(file, line) && count < max)
    {
        stringstream ss(line);
        string node, time;

        getline(ss, node, ',');
        getline(ss, time);

        char n = node[0];
        int t = stoi(time);

        signals[count].add_signal(n, t);
        count++;
    }
    file.close();
    return count;
}

int read_emergency_vehicles(string name, Emergency_Vehicle emergencyVehicles[], int max)
{
    ifstream file(name);
    string line;
    int count = 0;

    getline(file, line); // Skip header

    while (getline(file, line) && count < max)
    {
        stringstream ss(line);
        string id, start, end, priority;

        getline(ss, id, ',');
        getline(ss, start, ',');
        getline(ss, end, ',');
        getline(ss, priority);

        emergencyVehicles[count].add_emergency_vehicle(id, start[0], end[0], priority);
        count++;
    }
    file.close();
    return count;
}

void read_road_closures(string filename, Graph &g)
{
    ifstream file(filename);
    string line;

    getline(file, line);
    while (getline(file, line))
    {
        stringstream ss(line);
        string a, b, status;

        getline(ss, a, ',');
        getline(ss, b, ',');
        getline(ss, status);

        char start = a[0];
        char end = b[0];

        Node *temp = g.array[start - 'A'];
        bool check = false;
        // here we updated the road or edge status
        while (temp)
        {
            if (temp->vertx == end)
            {
                temp->status = status;
                check = true;
                break;
            }
            temp = temp->next;
        }
        // if not found in forward then check in reverse

        if (!check)
        {
            temp = g.array[end - 'A'];
            while (temp)
            {
                if (temp->vertx == start)
                {
                    temp->status = status;

                    break;
                }
                temp = temp->next;
            }
        }
    }
    file.close();
}

void simulate_vehicles(Graph &g, Vehicle vehicles[], int vehicles_count, int num_vertices)
{
    int array[26] = {0};

    cout << endl
         << "Simulating vehicles movements:" << endl;
    for (int i = 0; i < vehicles_count; ++i)
    {
        cout << "Vehicle " << vehicles[i].ID << ":" << endl;
        int road_Counts[26][26] = {0};
        g.dijkstra_algorithm(vehicles[i].Start, vehicles[i].End, road_Counts);
        for (int j = 0; j < 26; j++)
        {
            for (int k = 0; k < 26; k++)
            {
                if (road_Counts[j][k] > 0)
                {
                    array[j] = array[j] + road_Counts[j][k];
                }
            }
        }
    }
}
int main()
{

    int number_verteces = 26;
    Graph g(number_verteces);
    read_nodes("road.csv", g);
    int road_count[26][26] = {0};
    Vehicle vehicles[100];
    int vehicles_count = read_vehicles("vehicles.csv", vehicles, 100);
    Trafic_signal signals[100];
    int signal_count = read_trafic_signals("traffic_signals.csv", signals, 100);

    int choice;
    bool check = true;

    while (check)
    {
        cout << endl;
        cout << "Smart Traffic Management System Simulator" << endl;
        cout << "0. Remove Edge" << endl;
        cout << "1. Display City Traffic Network" << endl;
        cout << "2. Display Traffic Signal" << endl;
        cout << "3. Display Congestion Status" << endl;
        cout << "4. Display Blocked Road" << endl;
        cout << "5. Handle Emergency Vehicle Routing" << endl;
        cout << "6. Block Road due to Accident" << endl;
        cout << "7. Simulate Vehicle Routing " << endl;
        cout << "8. Display all path " << endl;
        cout << "9. Exit Simulation" << endl;
        cout << "Enter your Choice: ";

        cin >> choice;
        if (choice == 0)
        {
            cout << "Enter starting point :";
            char start;
            cin >> start;
            cout << "Enter ending point : ";
            char end;
            cin >> end;

            if (start >= 'A' && start <= 'Z' && end >= 'A' && end <= 'Z')
            {
                g.removeEdge(start, end);
                cout << "Edge removed between " << start << " and " << end << endl;
            }
            else
            {
                cout << "Invalid input" << endl;
            }
        }

        if (choice == 1)
        {
            cout << "Displaying City Traffic Network..." << endl;
            g.display_graph();
            cout << endl;
        }
        else if (choice == 2)
        {
            cout << "Displaying Traffic Signal..." << endl;
            for (int i = 0; i < signal_count; ++i)
            {
                signals[i].display();
            }
        }
        else if (choice == 3)
        {
            cout << "Displaying Congestion Status..." << endl;
            int vehicles_count = read_vehicles("vehicles.csv", vehicles, 100);
            cout << "\nCalculating routes for all vehicles:" << endl;
            for (int i = 0; i < vehicles_count; i++)
            {
                g.dijkstra_algorithm(vehicles[i].Start, vehicles[i].End, road_count);
            }
            for (int i = 0; i < number_verteces; i++)
            {
                for (int j = i + 1; j < number_verteces; j++)
                {
                    if (road_count[i][j] > 0)
                    {
                        cout << char('A' + i) << " -> " << char('A' + j)
                             << ": " << road_count[i][j] << " vehicles" << endl;
                    }
                }
            }
        }
        else if (choice == 4)
        {
            cout << "Displaying Blocked Road..." << endl;
            read_road_closures("road_closures.csv", g);
            g.displayblockroads();
        }
        else if (choice == 5)
        {
            Emergency_Vehicle emergencyVehicles[100];
            int c;
            c = read_emergency_vehicles("emergency_vehicles.csv", emergencyVehicles, 100);

            for (int i = 0; i < c; ++i)
            {
                emergencyVehicles[i].display();
            }
            cout << "Routing Emergency Vehicles..." << endl;
            cout << "Enter the route for emergency vehicle: ";
            char start, end;
            cout << "start: ";
            cin >> start;
            cout << "end: ";
            cin >> end;
            g.dijkstra_algorithm(start, end, road_count);
        }
        else if (choice == 6)
        {
            cout << "Blocking a Road..." << endl;
            cout << "Enter the road to block: ";
            char start, end;
            cout << "start: ";
            cin >> start;
            cout << "end: ";
            cin >> end;
            g.Blocking_road(start, end);
        }
        else if (choice == 7)
        {
            cout << "Simulating Vehicle Routing for All Paths..." << endl;
            int vehicles_count = read_vehicles("vehicles.csv", vehicles, 100);
            simulate_vehicles(g, vehicles, vehicles_count, number_verteces);
        }
        else if (choice == 8)
        {
            cout << "Displaying all path..." << endl;
            cout << "Enter the start point: ";
            char start;
            cin >> start;
            cout << "Enter the end point: ";
            char end;
            cin >> end;
            g.print_path_bfs(start, end);
        }
        else if (choice == 9)
        {
            cout << "Exiting Simulation..." << endl;
            check = false;
        }
        else
        {
            cout << "Invalid choice." << endl;
        }
    }
    return 0;
}
